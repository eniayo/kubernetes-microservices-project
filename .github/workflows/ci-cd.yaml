name: Microservices CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: microservices-cluster
  ORDER_SERVICE_IMAGE: order-service
  PRODUCT_SERVICE_IMAGE: product-service
  ECR_REPOSITORY: ${{ github.repository_owner }}/microservices

jobs:
  test:
    name: Test Services
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [order-service, product-service]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Install dependencies
        run: |
          cd microservices/${{ matrix.service }}
          python -m pip install --upgrade pip
          pip install pytest pytest-cov
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
      
      - name: Run tests
        run: |
          cd microservices/${{ matrix.service }}
          pytest tests/ --cov=app

  build:
    name: Build and Push Docker Images
    needs: test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [order-service, product-service]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      - name: Create ECR repository if not exists
        run: |
          # Check if repository exists and create if it doesn't
          if ! aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }}/${{ matrix.service }} 2>/dev/null; then
            echo "Creating ECR repository ${{ env.ECR_REPOSITORY }}/${{ matrix.service }}..."
            aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }}/${{ matrix.service }}
          else
            echo "ECR repository ${{ env.ECR_REPOSITORY }}/${{ matrix.service }} already exists"
          fi
      
      - name: Extract branch name
        shell: bash
        run: echo "BRANCH_NAME=$(echo ${GITHUB_REF#refs/heads/})" >> $GITHUB_ENV
      
      - name: Generate image tags
        id: tags
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "TAG=pr-${{ github.event.pull_request.number }}" >> $GITHUB_ENV
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "TAG=${{ inputs.environment }}-${GITHUB_SHA::8}" >> $GITHUB_ENV
          else
            echo "TAG=${BRANCH_NAME}-${GITHUB_SHA::8}" >> $GITHUB_ENV
          fi
          echo "FULL_TAG=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}/${{ matrix.service }}:${TAG}" >> $GITHUB_ENV
      
      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: ./microservices/${{ matrix.service }}
          push: true
          tags: ${{ env.FULL_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Save image tag for deployment
        run: |
          mkdir -p image-tags
          echo "${{ env.FULL_TAG }}" > image-tags/${{ matrix.service }}.txt
      
      - name: Upload image tags
        uses: actions/upload-artifact@v3
        with:
          name: image-tags-${{ matrix.service }}
          path: image-tags/${{ matrix.service }}.txt

  update-helm-values:
    name: Update Helm Values with New Image Tags
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Download order-service image tag
        uses: actions/download-artifact@v3
        with:
          name: image-tags-order-service
          path: image-tags
      
      - name: Download product-service image tag
        uses: actions/download-artifact@v3
        with:
          name: image-tags-product-service
          path: image-tags
      
      - name: Install yq
        run: |
          wget https://github.com/mikefarah/yq/releases/download/v4.30.8/yq_linux_amd64 -O /usr/local/bin/yq
          chmod +x /usr/local/bin/yq
      
      - name: Extract image tags
        id: get-tags
        run: |
          ORDER_IMAGE_TAG=$(cat image-tags/order-service.txt)
          PRODUCT_IMAGE_TAG=$(cat image-tags/product-service.txt)
          echo "ORDER_IMAGE_TAG=${ORDER_IMAGE_TAG}" >> $GITHUB_ENV
          echo "PRODUCT_IMAGE_TAG=${PRODUCT_IMAGE_TAG}" >> $GITHUB_ENV
      
      - name: Update Helm values
        run: |
          # Update order-service Helm values
          yq e '.image.repository = "'"${ORDER_IMAGE_TAG%:*}"'" | .image.tag = "'"${ORDER_IMAGE_TAG##*:}"'"' -i custom-helm-values/order-values.yaml
          
          # Update product-service Helm values
          yq e '.image.repository = "'"${PRODUCT_IMAGE_TAG%:*}"'" | .image.tag = "'"${PRODUCT_IMAGE_TAG##*:}"'"' -i custom-helm-values/product-values.yaml
          
          cat custom-helm-values/order-values.yaml
          cat custom-helm-values/product-values.yaml
      
      - name: Commit and push updated Helm values
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions@github.com'
          git add custom-helm-values/order-values.yaml custom-helm-values/product-values.yaml
          git commit -m "Update Helm values with new image tags [skip ci]" || echo "No changes to commit"
          git push

  deploy:
    name: Deploy to EKS
    needs: update-helm-values
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.ref }}
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
      
      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client
      
      - name: Install Helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          helm version
      
      - name: Run deploy script
        run: |
          chmod +x deploy.sh
          ./deploy.sh
      
      - name: Verify deployment
        run: |
          echo "Checking deployment status..."
          kubectl get pods -n microservices
          kubectl get svc -n microservices
          
          # Get API Gateway URL
          echo "Getting API Gateway URL..."
          GATEWAY_URL=$(kubectl get svc apisix-gateway -n microservices -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          if [ -z "$GATEWAY_URL" ]; then
            echo "Warning: LoadBalancer hostname not available yet. This is normal if the LoadBalancer is still provisioning."
            echo "You can check the status later using: kubectl get svc apisix-gateway -n microservices"
            
            # Don't fail the pipeline if the URL isn't available yet
            exit 0
          fi
          
          echo "API Gateway URL: ${GATEWAY_URL}"
          echo "Deployment complete! You can access your services at this URL."
          
          # Print test commands for manual verification
          echo "You can test your endpoints with:"
          echo "curl -H \"Host: api.example.com\" http://${GATEWAY_URL}/products/"
          echo "curl -H \"Host: api.example.com\" http://${GATEWAY_URL}/orders/"